---
title: "Perlの配列アクセスを勘違いしていた"
date: "2021-12-13"
category: "TIL"
---

Perlで配列の要素を参照する方法を、2年くらいずっと勘違いしていたことを学んだ。

Perlの配列は`@hoge`で宣言して、2番目の要素は`@hoge[1]`でアクセスするものだとばかり思っていたのだけど、値へのアクセスは`$hoge[1]`が正しいということを知った。言語仕様を体系的に理解せずに使ってると陥る悪い例である。

発覚の経緯は、職場のPerl専門家に「なんで配列は`@`で要素アクセスするのに、ハッシュは`%`じゃなく`$`で要素アクセスするんですか？」と聞いたことによる。

`$`はスカラを示すシジルであって、配列の要素ひとつひとつはスカラなので`$`で要素参照するとのこと。なるほど。宣言時に付けたシジルがついて回るわけではなく、どのように参照したいかによってシジルを変えるということのようだ。

それでも納得いかなかったのが、以下のように`@hoge[1]`で参照しても要素を見られること。

```perl
my @hoge = (100,200,300);

print @hoge[1]; #=> 200

print $hoge[1]; #=> 200
```
`$`と`@`どっちでもアクセスできるなんてどうなっているのだ・・・！？と思って混乱しかけたところで、スライスという構文があることを思い出した。

```perl
my @hoge = (10,20,30,40,50);
my @fuga = @hoge[1,2]; # 配列のスライス

print $fuga[0]; #=> 20

my %foo = (a => 11, b => 22, c => 33);
my @bar = @foo{b,c}; # ハッシュのスライス

print $bar[0]; #=> 22
```

配列やハッシュから複数の値を配列として取り出す時に使う`@`。ひょっとして1要素に対してのスライスがたまたま許されている、ということなんじゃないだろうかと思った。一次情報で裏が取れていないのでただの推測。

だとしても、配列で取り出すはずのスライスをスカラ変数で受けられているのも若干気持ち悪い。このあたりはPerlのデータ型をもう少し詳しく理解する必要がありそう。

```perl
my @hoge = (10,20,30,40,50);
my $fuga = @hoge[2];

print $fuga; #=> 30
```

やっぱりPerlは難しい。

ちなみに動作確認は[paiza.io](https://paiza.io/help?locale=ja-jp)で実施した。確認時のバージョンは`5.30.0`。

